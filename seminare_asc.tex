\documentclass[a4paper]{article}
\usepackage[a4paper, margin=0.2in]{geometry}
\usepackage{multicol}
\usepackage[compact]{titlesec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}       % Extra math symbols (provides \mathbb, etc.)
\usepackage{array}         % Essential for custom table columns
\usepackage{colortbl}      % Improves color handling in tables
\usepackage[table]{xcolor} % For coloring table cells and rows
\usepackage{graphicx}      % For including images
\usepackage{listings}      % For formatting code snippets
\usepackage[framemethod=default]{mdframed} % REPLACEMENT: A robust package for framed boxes
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{hyperref}

\definecolor{codegray}{rgb}{0.9,0.9,0.9}
\definecolor{darkblue}{rgb}{0.0,0.0,0.5}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5ex}

\titlespacing*{\section}{0pt}{1.5ex}{1ex}
\titlespacing*{\subsection}{0pt}{1ex}{0.5ex}
\titleformat*{\section}{\bfseries\large}
\titleformat*{\subsection}{\bfseries\normalsize}
\setcounter{secnumdepth}{0}
\setlist{nosep}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\renewcommand{\arraystretch}{1.4}
\newcommand{\hl}[1]{\textcolor{violet}{\textit{#1}}}

\newcommand{\binarysum}[3]{%
    \[
    \begin{array}{r|l}
    \text{#1} \\[-3pt]
    \text{#2} & + \\[-3pt]
    \hline
    \hl{#3} \\
    \end{array}
    \]
}
\newcommand{\binaryand}[3]{%
    \[
    \begin{array}{r|l}
    \text{#1} \\[-3pt]
    \text{#2} & AND \\[-3pt]
    \hline
    \hl{#3} \\
    \end{array}
    \]
}
\newcommand{\binaryor}[3]{%
    \[
    \begin{array}{r|l}
    \text{#1} \\[-3pt]
    \text{#2} & OR \\[-3pt]
    \hline
    \hl{#3} \\
    \end{array}
    \]
}
\newcommand{\binaryxor}[3]{%
    \[
    \begin{array}{r|l}
    \text{#1} \\[-3pt]
    \text{#2} & XOR \\[-3pt]
    \hline
    \hl{#3} \\
    \end{array}
    \]
}
\newcommand{\doublebinaryxor}[4]{%
    \begingroup\obeyspaces
    \[
    \begin{array}{r|l}
    \text{#1} \\[-3pt]
    \text{#2} & XOR \\[-3pt]
    \text{#3} & XOR \\[-3pt]
    \hline
    \hl{#4} \\
    \end{array}
    \]
    \endgroup
}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{codegray},
    commentstyle=\color{darkblue},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{red},
    basicstyle=\ttfamily\tiny,
    breaklines=true,
    numbers=left,
    numbersep=4pt,
    tabsize=2
}
\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan,
}

\newmdenv[
    linecolor=blue!75!black,
    backgroundcolor=blue!5!white,
    linewidth=1pt,
    innertopmargin=0.5\baselineskip,
    innerbottommargin=0.5\baselineskip,
    innerleftmargin=6pt,
    innerrightmargin=6pt,
    frametitlefont=\bfseries
]{definitionbox}

\newenvironment{definition}[1]
    {\begin{definitionbox}[frametitle={#1}]}
    {\end{definitionbox}}

\title{\Large\bfseries Seminare ASC - Rezolvări}
\author{
  Matei-Iulian Cocu\\
  \texttt{matei-iulian.cocu@s.unibuc.ro}
  \and
  Ștefan Chiper\\
  \texttt{stefan.chiper@s.unibuc.ro}
} \date{}
\renewcommand*\contentsname{\large\bfseries Cuprins}

\begin{document}
\maketitle
\vspace{0.5ex}
\hrule
\vspace{0.5ex}
\pagestyle{empty}
\tableofcontents
\newpage
\footnotesize

\section{Seminar 0x00}
\textbf{1.} Completați următorul tabel cu reprezentările lipsă ale unor numere naturale:
\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{10pt}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Baza: $B=2$} & \textbf{$B=4$} & \textbf{$B=8$} & \textbf{$B=10$} & \textbf{$B=16$} \\ \hline
 \hl{1011 1110 1110 1111} & \hl{2332 3233} & \hl{137 357} & \hl{48879} & 0xBEEF \\ \hline
 \hl{0000 0000 0010 1010} & \hl{222} & \hl{52} & 42 & \hl{0x002A} \\ \hline
 1001 1100 1111 0011 & \hl{2130 3303} & \hl{116 363} & \hl{40179} & \hl{0x9CF3} \\ \hline
 \hl{0000 0010 1011 1101} & 22331 & \hl{1275} & \hl{701} & \hl{0x02BD} \\ \hline
 \hl{0000 0001 1111 1111} & \hl{13333} & 777 & \hl{511} & \hl{0x01FF} \\ \hline
 \hl{1101 1110 1010 1111} & \hl{3132 2233} & \hl{157 257} & \hl{57007} & 0xDEAF \\ \hline
 1100 1010 0101 0011 & \hl{3022 1103} & \hl{145 123} & \hl{51795} & \hl{0xCA53} \\ \hline
 \hl{0000 0000 1110 0100} & 3210 & \hl{344} & \hl{228} & \hl{0x00E4} \\ \hline
 \hl{0000 1110 1001 1101} & \hl{322131} & 7235 & \hl{3741} & \hl{0x0E9D} \\ \hline
 \hl{0000 0111 1110 0100} & \hl{133210} & \hl{3744} & 2020 & \hl{0x07E4}\\ \hline
 \hl{0001 0001 0001 0001} & \hl{101 0101} & \hl{10 421} & \hl{4,369} & 0x1111 \\ \hline
 \hl{1111 1111 1111 1111} & \hl{3333 3333} & \hl{177 777} & \hl{65535} & 0xFFFF \\ \hline
 1111 1111 0000 0000 & \hl{3333 0000} & \hl{177 400} & \hl{65280} & \hl{0xFF00} \\ \hline
 0000 0000 1111 1111 & \hl{3333} & \hl{377} & \hl{255} & \hl{0x00FF} \\ \hline
\end{tabular}
\end{table}
\vspace{0.75cm}

\textbf{2.} Completați următorul tabel cu reprezentările lipsă ale unor numere întregi (16 biți):
\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{10pt}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Baza: $B=2$} & \textbf{$B=4$} & \textbf{$B=8$} & \textbf{$B=10$} & \textbf{$B=16$} \\ \hline
 \hl{1111 1110 1110 1101} & \hl{3332 3231} & \hl{177 355} & \hl{} & 0xFEED \\ \hline
 \hl{} & \hl{} & \hl{} & -42 & \hl{0x} \\ \hline
 0101 1100 1111 0011 & \hl{1130 3303} & \hl{} & \hl{} & \hl{0x} \\ \hline
 \hl{} & 22331 & \hl{} & \hl{} & \hl{0x} \\ \hline
 \hl{} & \hl{} & 777 & \hl{} & \hl{0x} \\ \hline
 \hl{} & \hl{} & \hl{} & \hl{} & 0xA1F1\\ \hline
 1100 1010 0101 0011 & \hl{} & \hl{} & \hl{} & \hl{0x} \\ \hline
 \hl{} & 3210 & \hl{} & \hl{} & \hl{0x} \\ \hline
 \hl{} & \hl{} & 7007 & \hl{} & \hl{0x} \\ \hline
 \hl{} & \hl{} & \hl{} & -1337 & \hl{0x} \\ \hline
 \hl{} & \hl{} & \hl{} & \hl{} & 0xF111 \\ \hline
 \hl{} & \hl{} & \hl{} & \hl{} & 0xFFFF \\ \hline
 1111 1111 0000 0000 & \hl{3333 0000} & \hl{} & \hl{} & \hl{0xFF00} \\ \hline
 1111 0000 1111 0000 & \hl{3300 3300} & \hl{} & \hl{} & \hl{0xF0F0} \\ \hline
\end{tabular}
\end{table}
\vspace{0.75cm}

\textbf{3.} Realizați următoarele operații aritmetice cu numere pe biți reprezentate în complement față de doi (verificați-vă calculele folosind sistemul zecimal):
\begin{multicols}{2}
\binarysum{0101 1100 1111 0011}{1111 1111 0000 0000}{\textit{overflow} - \hl{0101 1011 1111 0011}}
\binarysum{0111 1111 1111 1111}{0000 0000 0000 0001}{\hl{1000 0000 0000 0000}}
\binarysum{1111 1111 1111 1111}{0000 0000 0000 0000}{\hl{1111 1111 1111 1111}}
\binarysum{1111 1111 1111 1111}{0000 0000 0000 0001}{\textit{overflow} - \hl{0000 0000 0000 0000}}
\binarysum{0101 1100 1111 0011}{0111 0000 1111 0000}{\hl{1100 1101 1110 0011}}
\binarysum{1000 0000 0000 0000}{0000 0000 0000 0001}{\hl{1000 0000 0000 0001}}
\end{multicols}

În următoarele cazuri, numărul de biți scriși reprezintă dimensiunea totală alocată pentru reprezentarea numerelor (14 și 8 biți în stânga, 12 și 8 biți în dreapta):
\begin{multicols}{2}
\binarysum{11 1000 0010 0101}{1011 1100}{\hl{11 1000 1110 0001}}
\binarysum{1100 1001 0010}{0100 1010}{\hl{1100 1101 1100}}
\end{multicols}
\vspace{0.75cm}

\textbf{4.} Realizați următoarele operații logice pe biți:
\begin{multicols}{2}
\binaryand{0101 1100 1111 0011}{0101 1100 1111 0011}{\hl{0101 1100 1111 0011}}
\binaryand{0111 1111 1111 1111}{0000 0000 0000 0001}{\hl{0000 0000 0000 0001}}
\binaryand{1101 1001 0110 0001}{1111 1111 0000 0000}{\hl{1101 1001 0000 0000}}
\binaryand{0000 0000 1111 1111}{0000 0001 0000 0000}{\hl{0000 0000 0000 0000}}
\binaryxor{1101 1100 1111 0011}{1101 1100 1111 0011}{\hl{0000 0000 0000 0000}}
\binaryor{0101 1100 1111 0011}{0111 0000 1111 0000}{\hl{0111 1100 1111 0011}}
\binaryor{0101 1100 1111 0011}{0000 0000 1111 1111}{\hl{0101 1100 1111 1111}}
\doublebinaryxor{1100 0110 1001 1110}{1001 1111 0110 1100}{1100 0110 1001 1110}{1001 1111 0110 1100}
\end{multicols}
\vspace{0.75cm}

\textbf{5.} Folosing cunoștințele de curs, răspundeți la următoarele întrebări:
\begin{enumerate}[label=(\alph*)]
    \item care este cel mai mare număr zecimal (natural) care se poate reprezenta pe $N$ biți? \hl{\textbf{R:} $2^N - 1$}
    \item care este cel mai mare număr zecimal (întreg) care se poate reprezenta (în complement față de doi) pe $N$ biți? dar cel mai mic? \\ \hl{\textbf{R:} $2^{N-1} - 1$(mare); $-2^{N-1}$(mic)}
    \item fie $x$ un număr natural, de câți biți este nevoie pentru a-l reprezenta în binar? \hl{\textbf{R:} $\lfloor \log_2(x) \rfloor + 1$}
    \item dacă un număr $x$ este reprezentat cu $k$ cifre în sistemul hexazecimal, de câți biți avem nevoie pentru a-l reprezenta în binar? \hl{\textbf{R:} $4k$}
    \item dacă un număr $x$ este reprezentat cu $k$ biți în sistemul binar, de câte cifre avem nevoie pentru a reprezenta $x$ în sistemul hexazecimal? \hl{\textbf{R:} $\frac{k}{4}$}
    \item dacă un număr $x$ este reprezentat cu $k$ cifre în sistemul zecimal, de câți biți avem nevoie pentru a-l reprezenta în binar? \hl{\textbf{R:} $\lceil k \cdot \log_2(10) \rceil$}
\end{enumerate}
\vspace{0.75cm}

\textbf{6.} Reprezentarea binară a unui număr poate fi extinsă la dreapta, cu numere sub-unitare în felul următor \textit{(binary fixed-point)}:
\[
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\dots & 2^{7} & 2^{6} & 2^{5} & 2^{4} & 2^{3} & 2^{2} & 2^{1} & 2^{0} & 2^{-1} & 2^{-2} & 2^{-3} & 2^{-4} & 2^{-5} & 2^{-6} & 2^{-7} & \dots \\ \hline
\end{array}
\]
\begin{itemize}
    \item calculați valorile în sistemul zecimal pentru următoarele numere reprezentate în formatul de mai sus (punctul stă între $2^{0}$ și $2^{-1}$):
        \begin{enumerate}[label=(\alph*)]
            \item \text{101.101        \hl{\textbf{R:} 5.625}}
            \item \text{111.001        \hl{\textbf{R:} 7.125}}
            \item \text{1110.00111     \hl{\textbf{R:} 14.21875}}
            \item \text{1010.0000011   \hl{\textbf{R:} 10.0234375}}
            \item \text{1111.0010011   \hl{\textbf{R:} 15.148438}}
        \end{enumerate}
    \item calculați valorile în sistemul binar fixed-point pentru următoarele numere reprezentate în formatul zecimal:
        \begin{enumerate}[label=(\alph*)]
            \item \text{$3.75$      \hl{\textbf{R:} 11.11}}
            \item \text{$12.3125$   \hl{\textbf{R:} 1100.0101}}
            \item \text{$3.078125$  \hl{\textbf{R:} 11.000101}}
            \item \text{$17.671875$ \hl{\textbf{R:} 10001.101011}}
            \item \text{$\frac{2}{3} \approx 0.6667$ \hl{\textbf{R:} 0.101010101010... (periodic)}}
        \end{enumerate}
    \item când au numere reprezentate în acest sistem o reprezentare finită (fără repetiția zecimalelor)? \hl{\textbf{R:} Atunci când partea fracționară poate fi exprimată ca o sumă finită de puteri negative ale lui 2, adică atunci când numărul fracționar este un multiplu finit al unei puteri negative a lui 2. Altfel, numerele care nu pot fi exprimate astfel vor avea o reprezentare periodică în binar.}
    \item cum arată un număr negativ reprezentat într-un astfel de sistem de reprezentare? Reprezentați $\frac{5}{8}$ și $-\frac{5}{8}$ în sistemul binary fixed-point (folosiți un sigur bit pentru reprezentarea părții întregi, gândiți-vă și cum folosiți un bit de semn și la  reprezentarea în complement față de doi). \\ \hl{\textbf{R:} Vom aloca 8 biți \textit{(1 byte)} pentru reprezentarea unui număr întreg. Similar cu reprezentarea în complement față de 2 a numerelor întregi, aceeași idee se aplică și pentru numerele din sistemul fixed-point: se calculează complementul față de 2 a numărului non-negativ și se adaugă 1 la acesta (un LSB în reprezentarea respectivă). Astfel, $\frac{5}{8} = 0.625 \rightarrow 0b0000.1010 \implies -\frac{5}{8} = -0.625 \rightarrow 0b1111.0110 = 0b1111.0101 + 0b0000.0001$.}
\end{itemize}
\vspace{0.75cm}

\textbf{7.} Demonstrați cum reprezentarea în complement față de doi a numărului $-x$ poate fi obținută prin inversarea tuturor biților lui $x$ și adunarea lui 1 la rezultat.
\begin{definition}{}
\textbf{R:} Fie $x$ un număr întreg pozitiv reprezentat pe $N$ biți. Reprezentarea sa binară este dată de suma:
\[
x = \sum_{i=0}^{N-1} b_i \cdot 2^i, \quad b_i \in \{0, 1\}
\]
Atunci, reprezentarea în complement față de doi a numărului $-x$ este dată de:
\[-x = 2^N - x = 2^N - \sum_{i=0}^{N-1} b_i \cdot 2^i = \sum_{i=0}^{N-1} (1 - b_i) \cdot 2^i + 1
\]
unde $\sum_{i=0}^{N-1} (1 - b_i) \cdot 2^i$ reprezintă inversarea tuturor biților lui $x$, iar adunarea lui 1 finalizează procesul de obținere a reprezentării în complement față de doi.
\end{definition}
\newpage

\textbf{8.} Demonstrați că metoda asocierii a $p$ termeni consecutivi este soluția corectă pentru problema transformării unui număr din baza $B$ în baza $B^p$, $p > 1, p \in \mathbb{N}$.
\begin{definition}{}
\textbf{R:} Fie un număr $N$ reprezentat în baza $B$ ca o secvență de cifre $d_k d_{k-1} \dots d_1 d_0$, unde fiecare cifră $d_i$ satisface $0 \leq d_i < B$. Atunci, valoarea acestui număr în baza 10 este dată de:
\[N = \sum_{i=0}^{k} d_i \cdot B^i\]
Pentru a transforma acest număr în baza $B^p$, împărțim secvența de cifre în grupuri de câte $p$ cifre, începând de la dreapta spre stânga. Fiecare grup de $p$ cifre reprezintă o cifră în baza $B^p$. Astfel, fiecare grup $G_j$ format din cifrele $d_{jp + p - 1} d_{jp + p - 2} \dots d_{jp}$ poate fi convertit în baza $B^p$ prin calculul:
\[C_j = \sum_{i=0}^{p-1} d_{jp + i} \cdot B^i\]
unde $C_j$ este cifra corespunzătoare în baza $B^p$. Prin această metodă, fiecare grup de $p$ cifre din baza $B$ este transformat într-o singură cifră în baza $B^p$, păstrând astfel valoarea numerică a numărului original. Aceasta demonstrează că metoda asocierii a $p$ termeni consecutivi este corectă pentru transformarea unui număr din baza $B$ în baza $B^p$.
\end{definition}

\textbf{9.} Demonstrați că $\lfloor log_{2}x \rfloor = i_{max}$ unde $x$ este un număr dat pe $N$ biți iar $i_{max} = max\{i | b_{i} = 1, \forall i = 0,\dots,N-1 \}$ unde $b_{i}$ reprezintă al $i$-lea bit din reprezentarea binară a numărului $x$. De exemplu, dacă $x = 00101110$ (46 zecimal) atunci $\lfloor log_{2}x \rfloor = 5$.
\begin{definition}{}
\textbf{R:} Fie $x$ un număr reprezentat pe $N$ biți, astfel încât:
\[x = \sum_{i=0}^{N-1} b_i \cdot 2^i, \quad b_i \in \{0, 1\}\]
Fie $i_{max} = \max\{i \mid b_i = 1, \forall i = 0, \dots, N-1\}$. Atunci, putem observa că: $2^{i_{max}} \leq x < 2^{i_{max} + 1}$
Aplicând logaritmul în baza 2 pe toate părțile inegalității, obținem:$i_{max} \leq \log_2(x) < i_{max} + 1$
Din această relație rezultă că:$\lfloor \log_2(x) \rfloor = i_{max}$.
\leavevmode
\end{definition}
\vspace{0.5cm}

\textbf{10.} În 2014, videoclipul melodiei "Gangnam Style" se apropia de \textit{2.147.483.647} vizualizări (adică $2^{31} - 1$). Cei de la Youtube au trebuit să facă niște modificări pentru a acomoda acest număr mare de vizualizări. Explicați ce s-a întâmplat: care este semnificația numărului de mai sus, care era riscul, și care e soluția pentru rezolvarea potențialei probleme. \\ \hl{\textbf{R:} Numărul de vizualizări era stocat într-o variabilă de tip întreg pe 32 de biți, folosind reprezentarea în complement față de doi. Astfel, valoarea maximă care putea fi stocată era $2^{31} - 1 = 2.147.483.647$. Când numărul de vizualizări a atins această valoare, orice incrementare ar fi cauzat un overflow, resetând contorul la o valoare negativă sau zero, ceea ce ar fi fost incorect. Soluția a fost trecerea la o reprezentare pe 64 de biți pentru stocarea numărului de vizualizări, permițând astfel un număr mult mai mare de vizualizări fără riscul de overflow. \href{https://stackoverflow.com/questions/27275150/advice-on-unsigned-int-gangnam-style-edition}{De ce nu \textbf{unsigned}?} regulile interne Youtube, pe scurt.}
\vspace{0.5cm}

\textbf{11.} În Anexa 1 aveți două implementări ale algoritmului de căutare binară; care este cea optimă?
\begin{multicols}{2}
    \begin{lstlisting}[language=C++]
    int binarySearch1(int arr[], int start, int end, int x)
    {
        if (end >= start)
        {
            int mid = start + (end - start) / 2;
            if (arr[mid] == x)
                return mid;
            if (arr[mid] > x)
                return binarySearch1(arr, start, mid - 1, x);
            return binarySearch1(arr, mid + 1, end, x);
        }
        return -1;
    }
    \end{lstlisting}
    \begin{lstlisting}[language=C++]
    int binarySearch2(int arr[], int start, int end, int x)
    {
        if (end >= start)
        {
            int mid = (start + end) / 2;
            if (arr[mid] == x)
                return mid;
            if (arr[mid] > x)
                return binarySearch2(arr, start, mid - 1, x);
            return binarySearch2(arr, mid + 1, end, x);
        }
        return -1;
    }
    \end{lstlisting}
\end{multicols}
\vspace{0.5cm}

\section{Seminar 0x01}
\textbf{1.} Avem un pachet de cărți de joc (52 de cărți). Luăm cărțile pentru prima dată afară din pachet. Câtă informație avem în acest moment despre cărți? Amestecăm cărțile aleator \textit{(apropo, cum facem asta, algoritmic, eficient?)}. Câtă informație avem acum în pachetul de cărți? \textit{(folosiți și aproximarea lui Stirling pentru calcularea rezultatului)}
\vspace{0.35cm}
\noindent \hl{\textbf{R:} Informația inițială este de $log_2(52!) \approx 225.58$ biți, iar după amestecare rămâne aceeași, deoarece amestecarea nu schimbă entropia sistemului. Amestecarea se poate face folosind \href{https://en.wikipedia.org/wiki/Fisher\%E2\%80\%93Yates_shuffle}{algoritmul Fisher-Yates}, care are complexitate O(n).}
\href{https://en.wikipedia.org/wiki/Stirling\%27s_approximation}{Aproximarea lui Stirling}

\textbf{2.} Se dă o urnă în care avem 5 bile roșii și 3 bile albastre. Ni se spune că cineva extrage o bilă din urnă și aceasta este albastră. Se cere:
\begin{enumerate}[label=(\alph*)]
    \item câtă informație primim în urma acestei observații?
    \item care a fost entropia urnei înainte de extragere și care este entropia urnei după extragere?
    \item continuați să calculați entropia presupunân că extragem pas cu pas toate bilele albastre;
    \item similar cu cerința anterioară pentru bilele roșii (începând cu urna inițială presupunem că extrageți rând pe rând fiecare bilă roșie și calculați entropia la fiecare pas).
\end{enumerate}


\textbf{3.} Se dau 12 bile. 11 dintre ele au aceeași greutate, iar una este mai ușoară. Folosind o balanță, care este numărul minim de cântăriri necesare pentru a identifica bila mai ușoară?


\textbf{4.}


\textbf{5.}


\textbf{6.}


\textbf{7.} Considerăm următorul mesaj bloc:
\[
\begin{tabular}{|c|c|c|c|}
\hline
$D_{00}$ & $D_{01}$ & $D_{02}$ & $P_{0l}$ \\
\hline
$D_{10}$ & $D_{11}$ & $D_{12}$ & $P_{1l}$ \\
\hline
$D_{20}$ & $D_{21}$ & $D_{22}$ & $P_{2l}$ \\
\hline
$P_{c1}$ & $P_{c2}$ & $P_{c3}$ & $P_{cl}$ \\
\hline
\end{tabular}
\]
Elementele $D_{ij}$ sunt date (deci avem 9 biți) iar elementele $P_{ij}$
\textbf{8.}


\textbf{9.}


\textbf{10.}
% \begin{definition}{}
%
% \end{definition}

\section{Seminar 0x02}
\section{Seminar 0x03}
\section{Seminar 0x04}
\section{Seminar 0x05}


% \begin{multicols}{2}

% \end{multicols}


\end{document}